name: CI/CD Pipeline  # GitHub Actions 워크플로우 이름

on:
  push:
    branches: [ dev ]  # dev 브랜치에 push가 발생하면 실행
  pull_request:
    branches: [ dev ]  # dev 브랜치로 Pull Request가 생성되면 실행

jobs:
  build:  # 빌드 작업 정의
    runs-on: ubuntu-latest  # 최신 Ubuntu 환경에서 실행

    steps:
      - uses: actions/checkout@v4  # 저장소 코드 체크아웃
        with:
          fetch-depth: 0  # 전체 Git 기록을 가져와야 Gradle 캐싱 및 버전 관리를 효과적으로 수행 가능

      - name: Set up JDK 21  # Java JDK 21 설치 및 설정
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'  # Temurin JDK 사용
          java-version: '21'  # JDK 21 버전 설정

      - name: Gradle Caching  # Gradle 캐시를 이용하여 빌드 속도 향상
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches  # Gradle 캐시 저장 경로
            ~/.gradle/wrapper  # Gradle 래퍼 저장 경로
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Make application.yml  # 애플리케이션 설정 파일(application.yml) 생성
        run: |
          cd ./src/main/resources
          echo "${{ secrets.APPLICATION_YML }}" > ./application.yml  # GitHub Secrets에서 설정값 불러오기
        shell: bash

      - name: Grant execute permission for gradlew  # Gradle 빌드 스크립트 실행 권한 부여
        run: |
          chmod +x gradlew

      - name: Setup Gradle  # Gradle 환경 설정
        uses: gradle/actions/setup-gradle@v4

      - name: Run build (Thin JAR)  # Gradle을 사용하여 프로젝트 빌드 및 Thin JAR 생성
        run: ./gradlew build
        env:  # 환경 변수 설정 (GitHub Secrets 활용)
          DB_URL: ${{ secrets.DB_URL }}
          DB_HOST_NAME: ${{ secrets.DB_HOST_NAME }}
          DB_HOST_PASSWORD: ${{ secrets.DB_HOST_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_EXPIRATION_TIME: ${{ secrets.JWT_EXPIRATION_TIME }}

      - name: Upload Thin JAR artifact  # 빌드된 JAR 파일을 GitHub Actions의 Artifact로 업로드
        uses: actions/upload-artifact@v4
        with:
          name: pickify-thin-jar  # Artifact 이름 지정
          path: build/libs/*.jar  # 업로드할 JAR 파일 경로

  deploy:  # 배포 작업 정의
    needs: build  # build 작업이 성공적으로 완료된 후 실행
    runs-on: ubuntu-latest  # 최신 Ubuntu 환경에서 실행

    steps:
      - uses: actions/checkout@v4  # 저장소 코드 체크아웃
        with:
          fetch-depth: 0  # 전체 Git 기록 가져오기

      - name: Check for merge commit  # Merge commit 여부 확인 (PR Merge가 아닌 경우 배포 건너뜀)
        id: check-merge
        run: |
          if [[ "$(git log -1 --pretty=%B)" != *"Merge pull request"* ]]; then
            echo "Not a merge commit. Skipping deployment."
            echo "skip-deployment=true" >> $GITHUB_ENV  # 환경 변수 설정
          else
            echo "skip-deployment=false" >> $GITHUB_ENV
          fi

      - name: Download build artifact  # 이전 빌드 단계에서 업로드한 JAR 파일 다운로드
        uses: actions/download-artifact@v4
        with:
          name: pickify-thin-jar  # 다운로드할 Artifact 이름
          path: build/libs/  # 다운로드 위치 지정

      - name: Deploy Thin JAR to EC2  # EC2 서버에 배포
        if: env.skip-deployment != 'true'  # Merge commit이 아닌 경우 배포 스킵
        env:
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}  # EC2 SSH 키 (GitHub Secrets에서 가져옴)
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}  # EC2 접속 계정
          EC2_HOST: ${{ secrets.EC2_HOST }}  # EC2 인스턴스 주소
          DB_URL: ${{ secrets.DB_URL }}
          DB_HOST_NAME: ${{ secrets.DB_HOST_NAME }}
          DB_HOST_PASSWORD: ${{ secrets.DB_HOST_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_EXPIRATION_TIME: ${{ secrets.JWT_EXPIRATION_TIME }}
        run: |
          echo "$EC2_SSH_KEY" > private_key.pem  # SSH 키 파일 생성
          chmod 600 private_key.pem  # SSH 키 권한 변경 (보안상 필수)

          # EC2_USERNAME 변수가 올바르게 설정되었는지 확인
          echo "EC2_USERNAME=${EC2_USERNAME}"

          # 빌드된 JAR 파일 목록 출력 (디버깅)
          ls -lh build/libs

          # 실행 가능한 JAR 파일 찾기
          jar_file=$(find build/libs -maxdepth 1 -type f -name '*-plain.jar' | head -n 1)

          # JAR 파일이 없으면 오류 발생
          if [ -z "$jar_file" ]; then
            echo "❌ ERROR: No valid plain JAR file found!"
            exit 1
          fi

          echo "✅ Selected Plain JAR File: $jar_file"

          # EC2 서버에 `plain.jar` 파일 전송
          scp -i private_key.pem -o StrictHostKeyChecking=no "$jar_file" $EC2_USERNAME@$EC2_HOST:/home/$EC2_USERNAME/

          # EC2에서 JAR 파일 실행 준비
          ssh -i private_key.pem -o StrictHostKeyChecking=no $EC2_USERNAME@$EC2_HOST << 'EOF'
            export DB_URL=${DB_URL}
            export DB_HOST_NAME=${DB_HOST_NAME}
            export DB_HOST_PASSWORD=${DB_HOST_PASSWORD}
            export JWT_SECRET=${JWT_SECRET}
            export JWT_EXPIRATION_TIME=${JWT_EXPIRATION_TIME}

            # 실행 중인 Java 프로세스 종료
            pgrep java | xargs -r kill -15
            sleep 3

            # Thin JAR 실행을 위한 의존성 디렉터리 생성 (권한 문제 해결)
            sudo mkdir -p /home/ubuntu/thin-libs
            sudo chown -R ubuntu:ubuntu /home/ubuntu/thin-libs

            # jar 파일 실행을 위한 권한 설정
            chmod +x /home/ubuntu/pickify-plain.jar
          
            # 1️⃣ Thin JAR이 실행되기 전에 필요한 라이브러리를 다운로드
            nohup java -Dthin.root=/home/ubuntu/thin-libs -jar /home/ubuntu/pickify-plain.jar --thin.dryrun > thin.log 2>&1

            # Thin JAR 실행 (의존성을 thin-libs 디렉터리에 저장)
            nohup java -Dthin.root=/home/ubuntu/thin-libs -jar /home/ubuntu/pickify-plain.jar > app.log 2>&1 &
          EOF

          # 사용한 SSH 키 파일 삭제
          rm -f private_key.pem

